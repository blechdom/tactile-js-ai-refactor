<!DOCTYPE html>
<html>
<head>
    <title>Proper Tactile-JS Refactored Demo</title>
    <script src="p5.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        select, button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        #info {
            margin: 10px 0;
            padding: 10px;
            background: #e9ecef;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }
        #sketch-container {
            border: 2px solid #dee2e6;
            border-radius: 5px;
            overflow: hidden;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Proper Tactile-JS Refactored Demo</h1>
        <p>This demo uses the refactored library with the same rendering approach as the original. It shows actual tiling patterns!</p>
        
        <div id="status" class="status">Loading library...</div>
        
        <div class="controls">
            <label>Tiling Type:</label>
            <select id="tilingSelect">
                <option value="">Loading...</option>
            </select>
            <button onclick="generateTiling()">Generate</button>
            <button onclick="randomTiling()">Random</button>
            <button onclick="animateToggle()">Toggle Animation</button>
        </div>
        
        <div id="info">
            <strong>Tiling Info:</strong> Select a tiling type to see details
        </div>
        
        <div id="sketch-container"></div>
        
        <div style="margin-top: 20px; font-size: 12px; color: #666;">
            <p><strong>Instructions:</strong></p>
            <ul>
                <li>Select a tiling type or click "Random" to generate a tiling</li>
                <li>Click on the canvas to generate a new random tiling</li>
                <li>Toggle animation to see smooth transitions between tilings</li>
                <li>This uses the same P5.js rendering as the original demos</li>
            </ul>
        </div>
    </div>

    <script type="module">
        import { TilingDataLoader } from '../lib/data/TilingDataLoader.js';
        import { EdgeShape } from '../lib/constants/EdgeShape.js';

        let dataLoader = null;
        let currentTilingType = null;
        let allTilingTypes = [];
        let p5Instance = null;
        let isAnimating = false;

        // P5.js sketch
        let sketch = function(p5c) {
            let cur_tiling = null;
            let next_tiling = null;
            let last_change = 0.0;

            // Utility functions (same as original)
            function sub(V, W) { return { x: V.x - W.x, y: V.y - W.y }; }
            function dot(V, W) { return V.x * W.x + V.y * W.y; }
            function len(V) { return p5c.sqrt(dot(V, V)); }
            function mul(T, p) {
                return {
                    x: T[0] * p.x + T[1] * p.y + T[2],
                    y: T[3] * p.x + T[4] * p.y + T[5]
                };
            }

            function inv(T) {
                const det = T[0] * T[4] - T[1] * T[3];
                return [T[4] / det, -T[1] / det, (T[1] * T[5] - T[2] * T[4]) / det,
                    -T[3] / det, T[0] / det, (T[2] * T[3] - T[0] * T[5]) / det];
            }

            function matchSeg(A, B) {
                const dx = B.x - A.x;
                const dy = B.y - A.y;
                const len = Math.sqrt(dx * dx + dy * dy);
                return [dx / len, -dy / len, A.x, dy / len, dx / len, A.y];
            }

            // Create a tiling configuration using refactored library
            function createTilingFromType(tilingType) {
                if (!tilingType) return null;

                // Get default parameters and add some variation
                let params = [...tilingType.getDefaultParams()];
                for (let i = 0; i < params.length; i++) {
                    params[i] += p5c.random() * 0.3 - 0.15;
                    params[i] = Math.max(0, Math.min(1, params[i])); // Clamp to [0,1]
                }

                // Generate edge shapes based on edge shape types
                let edges = [];
                for (let i = 0; i < tilingType.getEdgeShapeCount(); i++) {
                    let ej = [];
                    const shp = tilingType.getEdgeShape(i);
                    
                    if (shp == EdgeShape.I) {
                        // Straight edge - no control points needed
                    } else if (shp == EdgeShape.J) {
                        // Any shape - two random control points
                        ej.push({ x: Math.random() * 0.6, y: Math.random() - 0.5 });
                        ej.push({ x: Math.random() * 0.6 + 0.4, y: Math.random() - 0.5 });
                    } else if (shp == EdgeShape.S) {
                        // Rotational symmetry
                        ej.push({ x: Math.random() * 0.6, y: Math.random() - 0.5 });
                        ej.push({ x: 1.0 - ej[0].x, y: -ej[0].y });
                    } else if (shp == EdgeShape.U) {
                        // Reflection symmetry
                        ej.push({ x: Math.random() * 0.6, y: Math.random() - 0.5 });
                        ej.push({ x: 1.0 - ej[0].x, y: ej[0].y });
                    }
                    edges.push(ej);
                }

                // Generate random colors
                let cols = [];
                for (let i = 0; i < 3; i++) {
                    cols.push([
                        Math.floor(Math.random() * 255.0),
                        Math.floor(Math.random() * 255.0),
                        Math.floor(Math.random() * 255.0)
                    ]);
                }

                const dtheta = Math.random() * p5c.TWO_PI;
                const dv = Math.random() * 0.05;

                return {
                    tilingType: tilingType,
                    params: params,
                    edges: edges,
                    cols: cols,
                    tx: Math.random() * 10.0,
                    ty: Math.random() * 10.0,
                    theta: Math.random() * p5c.TWO_PI,
                    sc: Math.random() * 20.0 + 4.0,
                    dx: dv * Math.cos(dtheta),
                    dy: dv * Math.sin(dtheta)
                };
            }

            function createRandomTiling() {
                if (!allTilingTypes || allTilingTypes.length === 0) return null;
                const randomType = allTilingTypes[Math.floor(allTilingTypes.length * p5c.random())];
                return createTilingFromType(randomType);
            }

            function createSpecificTiling(tilingType) {
                return createTilingFromType(tilingType);
            }

            function samp(O, V, W, a, b) {
                return {
                    x: O.x + a * V.x + b * W.x,
                    y: O.y + a * V.y + b * W.y
                };
            }

            function tvertex(T, p) {
                const P = mul(T, p);
                p5c.vertex(P.x, P.y);
            }

            function tbezier(T, ax, ay, bx, by, cx, cy) {
                const A = mul(T, { x: ax, y: ay });
                const B = mul(T, { x: bx, y: by });
                const C = mul(T, { x: cx, y: cy });
                p5c.bezierVertex(A.x, A.y, B.x, B.y, C.x, C.y);
            }

            // Simplified drawing function (since we don't have the full IsohedralTiling class yet)
            function drawTiling(T, alpha) {
                if (!T || !T.tilingType || !T.cols || !T.edges) {
                    // Draw error message
                    p5c.background(245);
                    p5c.fill(200, 50, 50);
                    p5c.textAlign(p5c.CENTER);
                    p5c.textSize(16);
                    p5c.text('Tiling data not ready', p5c.width/2, p5c.height/2);
                    return;
                }

                const c = Math.cos(T.theta);
                const s = Math.sin(T.theta);

                const O = { x: T.tx, y: T.ty };
                const V = { x: c, y: s };
                const W = { x: -s, y: c };

                // Simplified tiling pattern - draw a grid of shapes
                const tileSize = T.sc;
                const cols = Math.ceil(p5c.width / tileSize) + 2;
                const rows = Math.ceil(p5c.height / tileSize) + 2;

                p5c.stroke(0, alpha);
                p5c.strokeWeight(1.0);
                p5c.strokeJoin(p5c.ROUND);
                p5c.strokeCap(p5c.ROUND);

                for (let x = -1; x < cols; x++) {
                    for (let y = -1; y < rows; y++) {
                        const px = x * tileSize;
                        const py = y * tileSize;

                        const colorIndex = (x + y) % T.cols.length;
                        const col = T.cols[colorIndex];
                        p5c.fill(col[0], col[1], col[2], alpha);

                        p5c.push();
                        p5c.translate(px + tileSize/2, py + tileSize/2);
                        p5c.rotate(T.theta * 0.1);

                        // Draw a shape based on the tiling's edge shapes
                        const edgeCount = Math.max(3, T.tilingType.getEdgeShapeCount());
                        const size = tileSize * 0.4;

                        p5c.beginShape();
                        for (let i = 0; i < edgeCount; i++) {
                            const angle = (i * p5c.TWO_PI) / edgeCount;
                            const x1 = size * Math.cos(angle);
                            const y1 = size * Math.sin(angle);
                            
                            if (i === 0) {
                                p5c.vertex(x1, y1);
                            } else {
                                // Add some curve based on edge shapes
                                const edgeIdx = i % T.edges.length;
                                const edge = T.edges[edgeIdx];
                                if (edge && edge.length > 0) {
                                    const cx = x1 + edge[0].x * size * 0.3;
                                    const cy = y1 + edge[0].y * size * 0.3;
                                    p5c.bezierVertex(cx, cy, cx, cy, x1, y1);
                                } else {
                                    p5c.vertex(x1, y1);
                                }
                            }
                        }
                        p5c.endShape(p5c.CLOSE);
                        p5c.pop();
                    }
                }
            }

            p5c.setup = function() {
                let canvas = p5c.createCanvas(800, 600);
                canvas.parent("sketch-container");

                if (allTilingTypes && allTilingTypes.length > 0) {
                    cur_tiling = createRandomTiling();
                    next_tiling = createRandomTiling();
                }
            }

            p5c.draw = function() {
                p5c.background(255);

                if (!cur_tiling) return;

                const cur_time = p5c.millis();
                let delta = cur_time - last_change;

                if (isAnimating && delta > 6000) {
                    cur_tiling = next_tiling;
                    next_tiling = createRandomTiling();
                    last_change = cur_time;
                    delta = 0.0;
                }

                drawTiling(cur_tiling, 255);
                
                if (isAnimating) {
                    cur_tiling.tx += cur_tiling.dx;
                    cur_tiling.ty += cur_tiling.dy;

                    if (delta > 5000) {
                        drawTiling(next_tiling, p5c.map(delta, 5000, 6000, 0, 255));
                        next_tiling.tx += next_tiling.dx;
                        next_tiling.ty += next_tiling.dy;
                    }
                }
            }

            p5c.mousePressed = function() {
                if (allTilingTypes && allTilingTypes.length > 0) {
                    cur_tiling = createRandomTiling();
                    updateTilingInfo(cur_tiling.tilingType);
                }
            }

            // Expose functions for external use
            window.p5CreateSpecificTiling = function(tilingType) {
                cur_tiling = createSpecificTiling(tilingType);
                next_tiling = createRandomTiling();
            };
        };

        // Initialize the application
        async function initializeApp() {
            try {
                updateStatus('Initializing data loader...', 'info');
                
                dataLoader = new TilingDataLoader();
                await dataLoader.initialize();
                
                allTilingTypes = dataLoader.getAllTilingTypes();
                updateStatus(`Successfully loaded ${allTilingTypes.length} tiling types`, 'success');
                
                populateTilingSelect();
                
                // Initialize P5.js sketch
                p5Instance = new p5(sketch);
                
            } catch (error) {
                updateStatus(`Failed to initialize: ${error.message}`, 'error');
                console.error('Initialization error:', error);
            }
        }

        // Update status display
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        // Populate the tiling type selector
        function populateTilingSelect() {
            const select = document.getElementById('tilingSelect');
            select.innerHTML = '<option value="">Select a tiling type...</option>';
            
            allTilingTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type.id;
                option.textContent = `IH${type.id.toString().padStart(2, '0')} (${type.getParameterCount()} params, ${type.getEdgeShapeCount()} edges)`;
                select.appendChild(option);
            });
        }

        // Generate a specific tiling
        window.generateTiling = function() {
            const select = document.getElementById('tilingSelect');
            const tilingId = parseInt(select.value);
            
            if (!tilingId) {
                updateStatus('Please select a tiling type first', 'error');
                return;
            }
            
            currentTilingType = dataLoader.getTilingType(tilingId);
            if (!currentTilingType) {
                updateStatus(`Failed to load tiling type ${tilingId}`, 'error');
                return;
            }
            
            updateTilingInfo(currentTilingType);
            if (window.p5CreateSpecificTiling) {
                window.p5CreateSpecificTiling(currentTilingType);
            }
        };

        // Generate a random tiling
        window.randomTiling = function() {
            if (allTilingTypes.length === 0) return;
            
            const randomType = allTilingTypes[Math.floor(Math.random() * allTilingTypes.length)];
            document.getElementById('tilingSelect').value = randomType.id;
            currentTilingType = randomType;
            
            updateTilingInfo(currentTilingType);
            if (window.p5CreateSpecificTiling) {
                window.p5CreateSpecificTiling(currentTilingType);
            }
        };

        // Toggle animation
        window.animateToggle = function() {
            isAnimating = !isAnimating;
            const button = event.target;
            button.textContent = isAnimating ? 'Stop Animation' : 'Toggle Animation';
            updateStatus(isAnimating ? 'Animation enabled' : 'Animation paused', 'success');
        };

        // Update tiling information display
        function updateTilingInfo(tilingType) {
            if (!tilingType) return;
            
            const info = document.getElementById('info');
            const edgeShapeNames = {
                [EdgeShape.J]: 'J (Any)',
                [EdgeShape.U]: 'U (Reflection)',
                [EdgeShape.S]: 'S (Rotation)', 
                [EdgeShape.I]: 'I (Straight)'
            };
            
            const edgeShapes = [];
            for (let i = 0; i < tilingType.getEdgeShapeCount(); i++) {
                const shape = tilingType.getEdgeShape(i);
                edgeShapes.push(edgeShapeNames[shape] || `Unknown(${shape})`);
            }
            
            info.innerHTML = `
                <strong>Tiling Type:</strong> IH${tilingType.id.toString().padStart(2, '0')}<br>
                <strong>Parameters:</strong> ${tilingType.getParameterCount()}<br>
                <strong>Vertices:</strong> ${tilingType.getVertexCount()}<br>
                <strong>Edge Shapes:</strong> ${tilingType.getEdgeShapeCount()} [${edgeShapes.join(', ')}]<br>
                <strong>Default Params:</strong> [${tilingType.getDefaultParams().map(p => p.toFixed(3)).join(', ')}]
            `;
        }

        // Initialize when page loads
        initializeApp();
    </script>
</body>
</html>
