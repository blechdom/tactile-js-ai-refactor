<!DOCTYPE html>
<html>
<head>
    <title>Working Tactile-JS Refactored Demo</title>
    <script src="p5.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        select, button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        #info {
            margin: 10px 0;
            padding: 10px;
            background: #e9ecef;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }
        #sketch-container {
            border: 2px solid #dee2e6;
            border-radius: 5px;
            overflow: hidden;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        .note {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Working Tactile-JS Refactored Demo</h1>
        <p>This demo shows what works with the current refactored library (data access) and what's still needed.</p>
        
        <div class="note">
            <strong>Current Status:</strong> The refactored library successfully extracts and provides access to all tiling data. 
            The complete IsohedralTiling class with all geometric algorithms has been implemented! 
            This demo shows the data visualization capabilities. For full tiling functionality, see the Full Tiling Demo.
        </div>
        
        <div id="status" class="status">Loading library...</div>
        
        <div id="loading-progress" style="display: none; margin: 10px 0;">
            <div style="background: #e9ecef; border-radius: 10px; height: 20px; overflow: hidden;">
                <div id="progress-bar" style="background: #007bff; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
            </div>
            <div style="text-align: center; margin-top: 5px; font-size: 12px;" id="progress-text">Initializing...</div>
        </div>
        
        <div class="controls">
            <label>Tiling Type:</label>
            <select id="tilingSelect">
                <option value="">Loading...</option>
            </select>
            <button onclick="generateTiling()">Generate</button>
            <button onclick="randomTiling()">Random</button>
            <button onclick="nextTiling()">Next</button>
            <button onclick="prevTiling()">Previous</button>
        </div>
        
        <div id="info">
            <strong>Tiling Info:</strong> Select a tiling type to see details
        </div>
        
        <div id="sketch-container"></div>
        
        <div style="margin-top: 20px; font-size: 12px; color: #666;">
            <p><strong>What's Working:</strong></p>
            <ul>
                <li>All 81 tiling types load correctly from refactored data</li>
                <li>Edge shapes, parameters, and coefficients are accessible</li>
                <li>Data integrity verified against original library</li>
                <li>Modular architecture with clean separation of concerns</li>
            </ul>
            <p><strong>What's Still Needed:</strong></p>
            <ul>
                <li>IsohedralTiling class with geometric algorithms</li>
                <li>fillRegionQuad() method for proper tiling</li>
                <li>Vertex calculation and shape generation</li>
                <li>Matrix operations and transformations</li>
            </ul>
            <p><strong>Note:</strong> For complete functionality, see the Full Tiling Demo which has all algorithms implemented!</p>
        </div>
    </div>

    <script type="module">
        import { TilingDataLoader } from '../lib/data/TilingDataLoader.js';
        import { EdgeShape } from '../lib/constants/EdgeShape.js';

        let dataLoader = null;
        let currentTilingType = null;
        let allTilingTypes = [];
        let currentIndex = 0;
        let p5Instance = null;

        // P5.js sketch that demonstrates the data access
        let sketch = function(p5c) {
            let animationOffset = 0;

            function drawDataVisualization(tilingType) {
                if (!tilingType) {
                    p5c.background(245);
                    p5c.fill(100);
                    p5c.textAlign(p5c.CENTER);
                    p5c.textSize(16);
                    p5c.text('No tiling type selected', p5c.width/2, p5c.height/2);
                    return;
                }

                try {
                    p5c.background(245);
                
                // Draw title
                p5c.fill(50);
                p5c.textAlign(p5c.CENTER);
                p5c.textSize(24);
                p5c.text(`IH${tilingType.id.toString().padStart(2, '0')} - Data Visualization`, p5c.width/2, 30);
                
                // Draw edge shapes as colored circles
                const edgeShapes = [];
                for (let i = 0; i < tilingType.getEdgeShapeCount(); i++) {
                    edgeShapes.push(tilingType.getEdgeShape(i));
                }
                
                p5c.textAlign(p5c.CENTER);
                p5c.textSize(12);
                p5c.text('Edge Shapes:', p5c.width/2, 60);
                
                const edgeColors = {
                    [EdgeShape.J]: [100, 150, 255], // Blue - Any
                    [EdgeShape.U]: [255, 100, 100], // Red - Reflection
                    [EdgeShape.S]: [100, 255, 100], // Green - Rotation
                    [EdgeShape.I]: [200, 200, 200]  // Gray - Straight
                };
                
                const edgeNames = {
                    [EdgeShape.J]: 'J',
                    [EdgeShape.U]: 'U', 
                    [EdgeShape.S]: 'S',
                    [EdgeShape.I]: 'I'
                };
                
                const edgeStartX = p5c.width/2 - (edgeShapes.length * 40) / 2;
                for (let i = 0; i < edgeShapes.length; i++) {
                    const shape = edgeShapes[i];
                    const color = edgeColors[shape] || [128, 128, 128];
                    
                    p5c.fill(color[0], color[1], color[2]);
                    p5c.stroke(50);
                    p5c.strokeWeight(2);
                    p5c.circle(edgeStartX + i * 40, 80, 30);
                    
                    p5c.fill(255);
                    p5c.noStroke();
                    p5c.textAlign(p5c.CENTER);
                    p5c.textSize(14);
                    p5c.text(edgeNames[shape] || '?', edgeStartX + i * 40, 85);
                }
                
                // Draw parameters as bars
                const params = tilingType.getDefaultParams();
                if (params.length > 0) {
                    p5c.fill(50);
                    p5c.textAlign(p5c.CENTER);
                    p5c.textSize(12);
                    p5c.text('Default Parameters:', p5c.width/2, 130);
                    
                    const barWidth = Math.min(300, p5c.width - 100) / params.length;
                    const startBarX = p5c.width/2 - (params.length * barWidth) / 2;
                    
                    for (let i = 0; i < params.length; i++) {
                        const value = params[i];
                        const barHeight = value * 100;
                        
                        // Animated color based on parameter value
                        const hue = (value * 360 + animationOffset) % 360;
                        p5c.colorMode(p5c.HSB);
                        p5c.fill(hue, 70, 90);
                        p5c.colorMode(p5c.RGB);
                        
                        p5c.stroke(50);
                        p5c.strokeWeight(1);
                        p5c.rect(startBarX + i * barWidth + 5, 200 - barHeight, barWidth - 10, barHeight);
                        
                        // Parameter value text
                        p5c.fill(50);
                        p5c.noStroke();
                        p5c.textAlign(p5c.CENTER);
                        p5c.textSize(10);
                        p5c.text(value.toFixed(3), startBarX + i * barWidth + barWidth/2, 215);
                        p5c.text(`P${i+1}`, startBarX + i * barWidth + barWidth/2, 230);
                    }
                } else {
                    p5c.fill(100);
                    p5c.textAlign(p5c.CENTER);
                    p5c.textSize(12);
                    p5c.text('No parameters for this tiling type', p5c.width/2, 150);
                }
                
                // Draw geometric pattern based on data
                p5c.push();
                p5c.translate(p5c.width/4, p5c.height - 150);
                
                const numVertices = tilingType.getVertexCount();
                const radius = 60;
                
                p5c.fill(50);
                p5c.textAlign(p5c.CENTER);
                p5c.textSize(12);
                p5c.text(`${numVertices} Vertices Pattern`, 0, -radius - 20);
                
                // Draw a pattern based on vertex count and edge shapes
                for (let ring = 0; ring < 3; ring++) {
                    const ringRadius = radius - ring * 20;
                    const numPoints = Math.max(3, numVertices - ring);
                    
                    for (let i = 0; i < numPoints; i++) {
                        const angle = (i * p5c.TWO_PI) / numPoints + animationOffset * 0.01;
                        const x = ringRadius * Math.cos(angle);
                        const y = ringRadius * Math.sin(angle);
                        
                        // Color based on edge shape at this position
                        const edgeIdx = i % edgeShapes.length;
                        const shape = edgeShapes[edgeIdx];
                        const color = edgeColors[shape] || [128, 128, 128];
                        
                        p5c.fill(color[0], color[1], color[2], 200 - ring * 50);
                        p5c.stroke(50, 100);
                        p5c.strokeWeight(1);
                        
                        const size = 6 + ring * 2;
                        if (shape === EdgeShape.I) {
                            p5c.rect(x - size/2, y - size/2, size, size);
                        } else if (shape === EdgeShape.S) {
                            p5c.triangle(x, y - size/2, x - size/2, y + size/2, x + size/2, y + size/2);
                        } else {
                            p5c.circle(x, y, size);
                        }
                    }
                }
                
                p5c.pop();
                
                // Draw simplified tiling preview
                p5c.push();
                p5c.translate(3 * p5c.width/4, p5c.height - 150);
                
                p5c.fill(50);
                p5c.textAlign(p5c.CENTER);
                p5c.textSize(12);
                p5c.text('Tiling Preview', 0, -radius - 20);
                
                // Draw a simplified tiling pattern
                const tileSize = 15;
                const gridCols = 6;
                const gridRows = 6;
                const startX = -gridCols * tileSize / 2;
                const startY = -gridRows * tileSize / 2;
                
                for (let x = 0; x < gridCols; x++) {
                    for (let y = 0; y < gridRows; y++) {
                        const px = startX + x * tileSize;
                        const py = startY + y * tileSize;
                        
                        // Color based on tiling type and position
                        const colorIndex = (x + y + tilingType.id) % edgeShapes.length;
                        const shape = edgeShapes[colorIndex];
                        const color = edgeColors[shape] || [128, 128, 128];
                        
                        p5c.fill(color[0], color[1], color[2], 180);
                        p5c.stroke(50, 150);
                        p5c.strokeWeight(0.5);
                        
                        // Draw different shapes based on edge shape count and type
                        const rotation = (x + y + animationOffset * 0.005) * 0.1;
                        p5c.push();
                        p5c.translate(px + tileSize/2, py + tileSize/2);
                        p5c.rotate(rotation);
                        
                        const shapeSize = tileSize * 0.7;
                        const sides = Math.max(3, Math.min(8, numVertices));
                        
                        // Draw polygon based on vertex count
                        p5c.beginShape();
                        for (let i = 0; i < sides; i++) {
                            const angle = (i * p5c.TWO_PI) / sides;
                            const r = shapeSize / 2;
                            const vx = r * Math.cos(angle);
                            const vy = r * Math.sin(angle);
                            p5c.vertex(vx, vy);
                        }
                        p5c.endShape(p5c.CLOSE);
                        
                        p5c.pop();
                    }
                }
                
                p5c.pop();
                
                // Draw data summary
                p5c.fill(50);
                p5c.textAlign(p5c.LEFT);
                p5c.textSize(10);
                const summary = [
                    `Type: IH${tilingType.id.toString().padStart(2, '0')}`,
                    `Parameters: ${tilingType.getParameterCount()}`,
                    `Vertices: ${tilingType.getVertexCount()}`,
                    `Edge Shapes: ${tilingType.getEdgeShapeCount()}`,
                    `Aspects: ${tilingType.getAspectCount()}`
                ];
                
                for (let i = 0; i < summary.length; i++) {
                    p5c.text(summary[i], 20, p5c.height - 80 + i * 15);
                }
                
                } catch (error) {
                    p5c.background(245);
                    p5c.fill(200, 50, 50);
                    p5c.textAlign(p5c.CENTER);
                    p5c.textSize(14);
                    p5c.text('Error rendering tiling data', p5c.width/2, p5c.height/2);
                    p5c.textSize(12);
                    p5c.text(error.message, p5c.width/2, p5c.height/2 + 20);
                    console.error('Rendering error:', error);
                }
            }

            p5c.setup = function() {
                let canvas = p5c.createCanvas(800, 500);
                canvas.parent("sketch-container");
            }

            p5c.draw = function() {
                animationOffset += 1;
                drawDataVisualization(currentTilingType);
            }

            p5c.mousePressed = function() {
                // Cycle to next tiling on click
                if (allTilingTypes && allTilingTypes.length > 0) {
                    window.nextTiling();
                }
            }
        };

        // Show loading progress
        function showProgress(percent, text) {
            const progressContainer = document.getElementById('loading-progress');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            
            progressContainer.style.display = 'block';
            progressBar.style.width = percent + '%';
            progressText.textContent = text;
        }

        function hideProgress() {
            document.getElementById('loading-progress').style.display = 'none';
        }

        // Initialize the application
        async function initializeApp() {
            try {
                updateStatus('Initializing data loader...', 'info');
                showProgress(10, 'Creating data loader...');
                
                dataLoader = new TilingDataLoader();
                showProgress(30, 'Loading tiling data...');
                
                await dataLoader.initialize();
                showProgress(70, 'Processing tiling types...');
                
                allTilingTypes = dataLoader.getAllTilingTypes();
                showProgress(90, 'Setting up interface...');
                
                populateTilingSelect();
                
                // Initialize P5.js sketch
                p5Instance = new p5(sketch);
                
                showProgress(100, 'Complete!');
                setTimeout(() => {
                    hideProgress();
                    updateStatus(`Successfully loaded ${allTilingTypes.length} tiling types`, 'success');
                }, 500);
                
                // Start with first tiling
                if (allTilingTypes.length > 0) {
                    currentTilingType = allTilingTypes[0];
                    document.getElementById('tilingSelect').value = currentTilingType.id;
                    updateTilingInfo(currentTilingType);
                }
                
            } catch (error) {
                hideProgress();
                updateStatus(`Failed to initialize: ${error.message}`, 'error');
                console.error('Initialization error:', error);
            }
        }

        // Update status display
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        // Populate the tiling type selector
        function populateTilingSelect() {
            const select = document.getElementById('tilingSelect');
            select.innerHTML = '<option value="">Select a tiling type...</option>';
            
            allTilingTypes.forEach((type, index) => {
                const option = document.createElement('option');
                option.value = type.id;
                option.textContent = `IH${type.id.toString().padStart(2, '0')} (${type.getParameterCount()}p, ${type.getEdgeShapeCount()}e, ${type.getVertexCount()}v)`;
                select.appendChild(option);
            });
        }

        // Generate a specific tiling
        window.generateTiling = function() {
            const select = document.getElementById('tilingSelect');
            const tilingId = parseInt(select.value);
            
            if (!tilingId) {
                updateStatus('Please select a tiling type first', 'error');
                return;
            }
            
            currentTilingType = dataLoader.getTilingType(tilingId);
            currentIndex = allTilingTypes.findIndex(t => t.id === tilingId);
            
            if (!currentTilingType) {
                updateStatus(`Failed to load tiling type ${tilingId}`, 'error');
                return;
            }
            
            updateTilingInfo(currentTilingType);
            updateStatus(`Loaded tiling type IH${tilingId.toString().padStart(2, '0')}`, 'success');
        };

        // Generate a random tiling
        window.randomTiling = function() {
            if (allTilingTypes.length === 0) return;
            
            currentIndex = Math.floor(Math.random() * allTilingTypes.length);
            const randomType = allTilingTypes[currentIndex];
            
            document.getElementById('tilingSelect').value = randomType.id;
            currentTilingType = randomType;
            
            updateTilingInfo(currentTilingType);
            updateStatus(`Random tiling: IH${randomType.id.toString().padStart(2, '0')}`, 'success');
        };

        // Navigate to next tiling
        window.nextTiling = function() {
            if (allTilingTypes.length === 0) return;
            currentIndex = (currentIndex + 1) % allTilingTypes.length;
            const nextType = allTilingTypes[currentIndex];
            
            document.getElementById('tilingSelect').value = nextType.id;
            currentTilingType = nextType;
            
            updateTilingInfo(currentTilingType);
            updateStatus(`Next: IH${nextType.id.toString().padStart(2, '0')}`, 'success');
        };

        // Navigate to previous tiling
        window.prevTiling = function() {
            if (allTilingTypes.length === 0) return;
            currentIndex = (currentIndex - 1 + allTilingTypes.length) % allTilingTypes.length;
            const prevType = allTilingTypes[currentIndex];
            
            document.getElementById('tilingSelect').value = prevType.id;
            currentTilingType = prevType;
            
            updateTilingInfo(currentTilingType);
            updateStatus(`Previous: IH${prevType.id.toString().padStart(2, '0')}`, 'success');
        };

        // Update tiling information display
        function updateTilingInfo(tilingType) {
            if (!tilingType) return;
            
            const info = document.getElementById('info');
            const edgeShapeNames = {
                [EdgeShape.J]: 'J (Any)',
                [EdgeShape.U]: 'U (Reflection)',
                [EdgeShape.S]: 'S (Rotation)', 
                [EdgeShape.I]: 'I (Straight)'
            };
            
            const edgeShapes = [];
            for (let i = 0; i < tilingType.getEdgeShapeCount(); i++) {
                const shape = tilingType.getEdgeShape(i);
                edgeShapes.push(edgeShapeNames[shape] || `Unknown(${shape})`);
            }
            
            info.innerHTML = `
                <strong>Tiling Type:</strong> IH${tilingType.id.toString().padStart(2, '0')} (${currentIndex + 1}/${allTilingTypes.length})<br>
                <strong>Parameters:</strong> ${tilingType.getParameterCount()} [${tilingType.getDefaultParams().map(p => p.toFixed(3)).join(', ')}]<br>
                <strong>Vertices:</strong> ${tilingType.getVertexCount()}<br>
                <strong>Edge Shapes:</strong> ${tilingType.getEdgeShapeCount()} [${edgeShapes.join(', ')}]<br>
                <strong>Aspects:</strong> ${tilingType.getAspectCount()}<br>
                <strong>Data Status:</strong> All data arrays loaded and accessible
            `;
        }

        // Initialize when page loads
        initializeApp();
    </script>
</body>
</html>
