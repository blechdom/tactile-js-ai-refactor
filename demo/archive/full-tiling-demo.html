<!DOCTYPE html>
<html>
<head>
    <title>Full Tactile-JS Refactored Demo</title>
    <script src="p5.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        select, button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        #info {
            margin: 10px 0;
            padding: 10px;
            background: #e9ecef;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
        }
        #sketch-container {
            border: 2px solid #dee2e6;
            border-radius: 5px;
            overflow: hidden;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        .status.info {
            background: #cce7ff;
            color: #004085;
        }
        .success-note {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎨 Full Tactile-JS Refactored Demo</h1>
        <p>This demo uses the complete refactored IsohedralTiling class with all geometric algorithms!</p>
        
        <div class="success-note">
            <strong>🎉 Success!</strong> This demo now includes the complete <code>IsohedralTiling</code> class with all methods:
            <code>fillRegionQuad()</code>, <code>getVertex()</code>, <code>shape()</code>, <code>parts()</code>, 
            <code>getT1()</code>, <code>getT2()</code>, and all matrix operations. It works exactly like the original!
        </div>
        
        <div id="status" class="status info">Loading library...</div>
        
        <div class="controls">
            <label>Tiling Type:</label>
            <select id="tilingSelect">
                <option value="">Loading...</option>
            </select>
            <button onclick="generateTiling()">Generate</button>
            <button onclick="randomTiling()">Random</button>
            <button onclick="animateToggle()">Toggle Animation</button>
        </div>
        
        <div id="info">
            <strong>Tiling Info:</strong> Select a tiling type to see details
        </div>
        
        <div id="sketch-container"></div>
        
        <div style="margin-top: 20px; font-size: 12px; color: #666;">
            <p><strong>Features:</strong></p>
            <ul>
                <li>✅ Complete IsohedralTiling class with all geometric algorithms</li>
                <li>✅ Real tiling mathematics using fillRegionQuad()</li>
                <li>✅ Proper edge shape rendering with bezier curves</li>
                <li>✅ Matrix transformations and vertex calculations</li>
                <li>✅ Color mapping and aspect handling</li>
                <li>✅ Animation and smooth transitions</li>
                <li>✅ Click to generate new random tilings</li>
            </ul>
        </div>
    </div>

    <script type="module">
        import { IsohedralTilingFactory } from '../lib/core/IsohedralTilingFactory.js';
        import { mul, matchSeg } from '../lib/core/IsohedralTiling.js';
        import { EdgeShape } from '../lib/constants/EdgeShape.js';

        let tilingFactory = null;
        let currentTiling = null;
        let availableTypes = [];
        let p5Instance = null;
        let isAnimating = false;

        // P5.js sketch that uses the complete IsohedralTiling class
        let sketch = function(p5c) {
            let cur_tiling = null;
            let next_tiling = null;
            let last_change = 0.0;

            // Utility functions (same as original)
            function sub(V, W) { return { x: V.x - W.x, y: V.y - W.y }; }
            function dot(V, W) { return V.x * W.x + V.y * W.y; }
            function len(V) { return p5c.sqrt(dot(V, V)); }

            function inv(T) {
                const det = T[0] * T[4] - T[1] * T[3];
                return [T[4] / det, -T[1] / det, (T[1] * T[5] - T[2] * T[4]) / det,
                    -T[3] / det, T[0] / det, (T[2] * T[3] - T[0] * T[5]) / det];
            }

            // Create a tiling configuration using the full IsohedralTiling class
            async function createRandomTiling() {
                if (!tilingFactory || availableTypes.length === 0) return null;

                const randomType = availableTypes[Math.floor(availableTypes.length * p5c.random())];
                const tiling = await tilingFactory.createTiling(randomType);

                // Add some parameter variation
                let params = tiling.getParameters();
                for (let i = 0; i < params.length; i++) {
                    params[i] += p5c.random() * 0.3 - 0.15;
                    params[i] = Math.max(0, Math.min(1, params[i])); // Clamp to [0,1]
                }
                tiling.setParameters(params);

                // Generate edge shapes based on edge shape types
                let edges = [];
                for (let i = 0; i < tiling.numEdgeShapes(); i++) {
                    let ej = [];
                    const shp = tiling.getEdgeShape(i);
                    
                    if (shp == EdgeShape.I) {
                        // Straight edge - no control points needed
                    } else if (shp == EdgeShape.J) {
                        // Any shape - two random control points
                        ej.push({ x: Math.random() * 0.6, y: Math.random() - 0.5 });
                        ej.push({ x: Math.random() * 0.6 + 0.4, y: Math.random() - 0.5 });
                    } else if (shp == EdgeShape.S) {
                        // Rotational symmetry
                        ej.push({ x: Math.random() * 0.6, y: Math.random() - 0.5 });
                        ej.push({ x: 1.0 - ej[0].x, y: -ej[0].y });
                    } else if (shp == EdgeShape.U) {
                        // Reflection symmetry
                        ej.push({ x: Math.random() * 0.6, y: Math.random() - 0.5 });
                        ej.push({ x: 1.0 - ej[0].x, y: ej[0].y });
                    }
                    edges.push(ej);
                }

                // Generate random colors
                let cols = [];
                for (let i = 0; i < 3; i++) {
                    cols.push([
                        Math.floor(Math.random() * 255.0),
                        Math.floor(Math.random() * 255.0),
                        Math.floor(Math.random() * 255.0)
                    ]);
                }

                const dtheta = Math.random() * p5c.TWO_PI;
                const dv = Math.random() * 0.05;

                return {
                    tiling: tiling,
                    edges: edges,
                    cols: cols,
                    tx: Math.random() * 10.0,
                    ty: Math.random() * 10.0,
                    theta: Math.random() * p5c.TWO_PI,
                    sc: Math.random() * 20.0 + 4.0,
                    dx: dv * Math.cos(dtheta),
                    dy: dv * Math.sin(dtheta)
                };
            }

            async function createSpecificTiling(tilingType) {
                if (!tilingFactory) return null;
                
                const tiling = await tilingFactory.createTiling(tilingType);
                
                // Generate edge shapes
                let edges = [];
                for (let i = 0; i < tiling.numEdgeShapes(); i++) {
                    let ej = [];
                    const shp = tiling.getEdgeShape(i);
                    
                    if (shp == EdgeShape.I) {
                        // Straight edge
                    } else if (shp == EdgeShape.J) {
                        ej.push({ x: Math.random() * 0.6, y: Math.random() - 0.5 });
                        ej.push({ x: Math.random() * 0.6 + 0.4, y: Math.random() - 0.5 });
                    } else if (shp == EdgeShape.S) {
                        ej.push({ x: Math.random() * 0.6, y: Math.random() - 0.5 });
                        ej.push({ x: 1.0 - ej[0].x, y: -ej[0].y });
                    } else if (shp == EdgeShape.U) {
                        ej.push({ x: Math.random() * 0.6, y: Math.random() - 0.5 });
                        ej.push({ x: 1.0 - ej[0].x, y: ej[0].y });
                    }
                    edges.push(ej);
                }

                let cols = [];
                for (let i = 0; i < 3; i++) {
                    cols.push([
                        Math.floor(Math.random() * 255.0),
                        Math.floor(Math.random() * 255.0),
                        Math.floor(Math.random() * 255.0)
                    ]);
                }

                return {
                    tiling: tiling,
                    edges: edges,
                    cols: cols,
                    tx: 0,
                    ty: 0,
                    theta: 0,
                    sc: 20.0,
                    dx: 0,
                    dy: 0
                };
            }

            function samp(O, V, W, a, b) {
                return {
                    x: O.x + a * V.x + b * W.x,
                    y: O.y + a * V.y + b * W.y
                };
            }

            function tvertex(T, p) {
                const P = mul(T, p);
                p5c.vertex(P.x, P.y);
            }

            function tbezier(T, ax, ay, bx, by, cx, cy) {
                const A = mul(T, { x: ax, y: ay });
                const B = mul(T, { x: bx, y: by });
                const C = mul(T, { x: cx, y: cy });
                p5c.bezierVertex(A.x, A.y, B.x, B.y, C.x, C.y);
            }

            // Draw tiling using the complete IsohedralTiling class (same as original)
            function drawTiling(T, alpha) {
                if (!T || !T.tiling) return;

                const c = Math.cos(T.theta);
                const s = Math.sin(T.theta);

                const O = { x: T.tx, y: T.ty };
                const V = { x: c, y: s };
                const W = { x: -s, y: c };

                const t1l = len(T.tiling.getT1());
                const t2l = len(T.tiling.getT2());
                const marg = 1.5 * p5c.sqrt(t1l * t1l + t2l * t2l);

                const pts = [
                    samp(O, V, W, -marg, -marg),
                    samp(O, V, W, T.sc + marg, -marg),
                    samp(O, V, W, T.sc + marg, T.sc * (p5c.height / p5c.width) + marg),
                    samp(O, V, W, -marg, T.sc * (p5c.height / p5c.width) + marg),
                ];

                const M = mul(
                    [p5c.width, 0.0, 0.0, 0.0, p5c.width, 0.0],
                    inv(matchSeg(O, samp(O, V, W, T.sc, 0.0))));

                p5c.stroke(0, alpha);
                p5c.strokeWeight(1.0);
                p5c.strokeJoin(p5c.ROUND);
                p5c.strokeCap(p5c.ROUND);

                // Use the real fillRegionQuad method!
                for (let i of T.tiling.fillRegionQuad(pts[0], pts[1], pts[2], pts[3])) {
                    const TT = i.T;
                    const CT = mul(M, TT);

                    const col = T.cols[T.tiling.getColour(i.t1, i.t2, i.aspect)];
                    p5c.fill(col[0], col[1], col[2], alpha);

                    p5c.beginShape();
                    tvertex(CT, T.tiling.getVertex(0));

                    // Use the real shape() method!
                    for (let si of T.tiling.shape()) {
                        const S = mul(CT, si.T);
                        if (si.shape == EdgeShape.I) {
                            tvertex(S, { x: si.rev ? 0.0 : 1.0, y: 0.0 });
                        } else {
                            const ej = T.edges[si.id];
                            if (si.rev) {
                                tbezier(S, ej[1].x, ej[1].y, ej[0].x, ej[0].y, 0.0, 0.0);
                            } else {
                                tbezier(S, ej[0].x, ej[0].y, ej[1].x, ej[1].y, 1.0, 0.0);
                            }
                        }
                    }
                    p5c.endShape(p5c.CLOSE);
                }
            }

            p5c.setup = function() {
                let canvas = p5c.createCanvas(800, 600);
                canvas.parent("sketch-container");
            }

            p5c.draw = function() {
                p5c.background(255);

                if (!cur_tiling) return;

                const cur_time = p5c.millis();
                let delta = cur_time - last_change;

                if (isAnimating && delta > 6000) {
                    cur_tiling = next_tiling;
                    createRandomTiling().then(newTiling => {
                        next_tiling = newTiling;
                    });
                    last_change = cur_time;
                    delta = 0.0;
                }

                drawTiling(cur_tiling, 255);
                
                if (isAnimating) {
                    cur_tiling.tx += cur_tiling.dx;
                    cur_tiling.ty += cur_tiling.dy;

                    if (next_tiling && delta > 5000) {
                        drawTiling(next_tiling, p5c.map(delta, 5000, 6000, 0, 255));
                        next_tiling.tx += next_tiling.dx;
                        next_tiling.ty += next_tiling.dy;
                    }
                }
            }

            p5c.mousePressed = function() {
                createRandomTiling().then(newTiling => {
                    if (newTiling) {
                        cur_tiling = newTiling;
                        updateTilingInfo(cur_tiling.tiling);
                    }
                });
            }

            // Expose functions for external use
            window.p5CreateSpecificTiling = function(tilingType) {
                createSpecificTiling(tilingType).then(newTiling => {
                    if (newTiling) {
                        cur_tiling = newTiling;
                        createRandomTiling().then(nextTiling => {
                            next_tiling = nextTiling;
                        });
                    }
                });
            };

            // Initialize with first tiling
            window.p5Initialize = function() {
                createRandomTiling().then(newTiling => {
                    cur_tiling = newTiling;
                    if (newTiling) {
                        updateTilingInfo(newTiling.tiling);
                    }
                    return createRandomTiling();
                }).then(nextTiling => {
                    next_tiling = nextTiling;
                });
            };
        };

        // Initialize the application
        async function initializeApp() {
            try {
                updateStatus('🔄 Initializing tiling factory...', 'info');
                
                tilingFactory = new IsohedralTilingFactory();
                await tilingFactory.initialize();
                
                availableTypes = tilingFactory.getAvailableTypes();
                updateStatus(`✅ Successfully loaded ${availableTypes.length} tiling types with full algorithms`, 'success');
                
                populateTilingSelect();
                
                // Initialize P5.js sketch
                p5Instance = new p5(sketch);
                
                // Initialize with first tiling
                setTimeout(() => {
                    if (window.p5Initialize) {
                        window.p5Initialize();
                    }
                }, 100);
                
            } catch (error) {
                updateStatus(`❌ Failed to initialize: ${error.message}`, 'error');
                console.error('Initialization error:', error);
            }
        }

        // Update status display
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }

        // Populate the tiling type selector
        function populateTilingSelect() {
            const select = document.getElementById('tilingSelect');
            select.innerHTML = '<option value="">Select a tiling type...</option>';
            
            availableTypes.forEach(typeId => {
                const option = document.createElement('option');
                option.value = typeId;
                option.textContent = `IH${typeId.toString().padStart(2, '0')}`;
                select.appendChild(option);
            });
        }

        // Generate a specific tiling
        window.generateTiling = function() {
            const select = document.getElementById('tilingSelect');
            const tilingId = parseInt(select.value);
            
            if (!tilingId) {
                updateStatus('⚠️ Please select a tiling type first', 'error');
                return;
            }
            
            if (window.p5CreateSpecificTiling) {
                window.p5CreateSpecificTiling(tilingId);
                updateStatus(`✅ Generated tiling IH${tilingId.toString().padStart(2, '0')}`, 'success');
            }
        };

        // Generate a random tiling
        window.randomTiling = function() {
            if (availableTypes.length === 0) return;
            
            const randomType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            document.getElementById('tilingSelect').value = randomType;
            
            if (window.p5CreateSpecificTiling) {
                window.p5CreateSpecificTiling(randomType);
                updateStatus(`🎲 Random tiling: IH${randomType.toString().padStart(2, '0')}`, 'success');
            }
        };

        // Toggle animation
        window.animateToggle = function() {
            isAnimating = !isAnimating;
            const button = event.target;
            button.textContent = isAnimating ? 'Stop Animation' : 'Toggle Animation';
            updateStatus(isAnimating ? '🎬 Animation enabled' : '⏸️ Animation paused', 'success');
        };

        // Update tiling information display
        function updateTilingInfo(tiling) {
            if (!tiling) return;
            
            const info = document.getElementById('info');
            const edgeShapeNames = {
                [EdgeShape.J]: 'J (Any)',
                [EdgeShape.U]: 'U (Reflection)',
                [EdgeShape.S]: 'S (Rotation)', 
                [EdgeShape.I]: 'I (Straight)'
            };
            
            const edgeShapes = [];
            for (let i = 0; i < tiling.numEdgeShapes(); i++) {
                const shape = tiling.getEdgeShape(i);
                edgeShapes.push(edgeShapeNames[shape] || `Unknown(${shape})`);
            }
            
            info.innerHTML = `
                <strong>Tiling Type:</strong> IH${tiling.getTilingType().toString().padStart(2, '0')}<br>
                <strong>Parameters:</strong> ${tiling.numParameters()} [${tiling.getParameters().map(p => p.toFixed(3)).join(', ')}]<br>
                <strong>Vertices:</strong> ${tiling.numVertices()}<br>
                <strong>Edge Shapes:</strong> ${tiling.numEdgeShapes()} [${edgeShapes.join(', ')}]<br>
                <strong>Aspects:</strong> ${tiling.numAspects()}<br>
                <strong>Status:</strong> ✅ Full IsohedralTiling class with all algorithms active
            `;
        }

        // Initialize when page loads
        initializeApp();
    </script>
</body>
</html>
