precision highp float;

uniform sampler2D tex;
uniform vec2 res;
// uniform vec4 Mv;
uniform mat3 M;
uniform bool dual_spiral;

varying vec2 uv;

void main()
{
	vec2 asp = vec2( 1.0, res.y / res.x );

	vec2 cen = 0.5 * asp;
	vec2 v = uv * asp;

	vec2 p = v - cen;

	if( dual_spiral ) {
		// Dual spiral MÃ¶bius transformation
		float dia = length( res );
		float c = res.x / dia;
		float s = res.y / dia;

		mat3 rot = mat3( c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0 );
		p = (rot*vec3(p,1.0)).xy;

		p = (1.5*p+vec2(0.5,0.0));
		float l = (p.x-1.0)*(p.x-1.0) + p.y*p.y;
		p = vec2( (p.x-p.x*p.x-p.y*p.y)/l, p.y/l );
	}
	// dual_spiral == false: no transformation (single spiral)

	// Mode-specific seam reduction techniques
	float angle = atan( p.y, p.x );
	
	if( dual_spiral ) {
		// Dual spiral: Multiple disjoint lines - use frequency-based smoothing
		float r = length(p);
		float smooth1 = sin( angle * 6.0 + r * 20.0 ) * 0.015;
		float smooth2 = cos( p.x * 100.0 + p.y * 80.0 ) * 0.008;
		float smooth3 = sin( r * 150.0 ) * 0.005; // Radial component
		angle += smooth1 + smooth2 + smooth3;
		
		// Add slight rotation offset to shift seams
		angle += 0.05;
	} else {
		// Single spiral: One main seam - gentler, targeted smoothing
		float smooth1 = sin( p.x * 90.0 + p.y * 70.0 ) * 0.012;
		float smooth2 = cos( length(p) * 120.0 ) * 0.006;
		
		// Targeted smoothing near the main discontinuity
		float seamDist = abs( mod( angle + 3.14159, 6.28318 ) - 3.14159 );
		if( seamDist < 0.15 ) {
			float blend = 1.0 - (seamDist / 0.15);
			angle += sin( length(p) * 80.0 + angle * 4.0 ) * 0.02 * blend;
		}
		
		angle += smooth1 + smooth2 + 0.08; // Offset main seam
	}
	
	vec2 merc = vec2( log( length( p ) ), angle );

	vec4 col = texture2D( tex, (M * vec3( merc, 1.0 )).xy );
	gl_FragColor = col;
}
