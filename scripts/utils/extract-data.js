#!/usr/bin/env node

/**
 * Data Extraction Script for Tactile-JS
 * 
 * This script extracts all data structures from the original tactile.js file
 * and generates a complete TilingData.js file with verification.
 */

const fs = require('fs');
const path = require('path');

// Read the original tactile.js file
const originalFile = path.join(__dirname, 'lib', 'tactile.js');
const originalContent = fs.readFileSync(originalFile, 'utf8');

// Extract all data structures
function extractDataStructures() {
    const data = {
        edgeShapes: {},
        edgeShapeIds: {},
        edgeOrientations: {},
        defaultParams: {},
        vertexCoeffs: {},
        translationCoeffs: {},
        aspectCoeffs: {},
        coloring: {},
        tilingTypes: []
    };

    // Extract edge shapes (es_XX)
    const esMatches = originalContent.match(/const es_\d+ = \[[^\]]+\]/g);
    esMatches.forEach(match => {
        const name = match.match(/es_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.edgeShapes[name] = values;
    });

    // Extract edge shape IDs (esi_XX)
    const esiMatches = originalContent.match(/const esi_\d+ = \[[^\]]+\]/g);
    esiMatches.forEach(match => {
        const name = match.match(/esi_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.edgeShapeIds[name] = values;
    });

    // Extract edge orientations (eo_XX)
    const eoMatches = originalContent.match(/const eo_\d+ = \[[^\]]+\]/g);
    eoMatches.forEach(match => {
        const name = match.match(/eo_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.edgeOrientations[name] = values;
    });

    // Extract default parameters (dp_XX)
    const dpMatches = originalContent.match(/const dp_\d+ = \[[^\]]+\]/g);
    dpMatches.forEach(match => {
        const name = match.match(/dp_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.defaultParams[name] = values;
    });

    // Extract vertex coefficients (tvc_XX)
    const tvcMatches = originalContent.match(/const tvc_\d+ = \[[\s\S]*?\];/g);
    tvcMatches.forEach(match => {
        const name = match.match(/tvc_\d+/)[0];
        const values = match.match(/\[([\s\S]*?)\];/)[1];
        data.vertexCoeffs[name] = values;
    });

    // Extract translation coefficients (tc_XX)
    const tcMatches = originalContent.match(/const tc_\d+ = \[[^\]]+\]/g);
    tcMatches.forEach(match => {
        const name = match.match(/tc_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.translationCoeffs[name] = values;
    });

    // Extract aspect coefficients (ac_XX)
    const acMatches = originalContent.match(/const ac_\d+ = \[[\s\S]*?\];/g);
    acMatches.forEach(match => {
        const name = match.match(/ac_\d+/)[0];
        const values = match.match(/\[([\s\S]*?)\];/)[1];
        data.aspectCoeffs[name] = values;
    });

    // Extract coloring (c_XX)
    const cMatches = originalContent.match(/const c_\d+ = \[[^\]]+\]/g);
    cMatches.forEach(match => {
        const name = match.match(/c_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.coloring[name] = values;
    });

    return data;
}

// Generate the complete TilingData.js file
function generateTilingDataFile(data) {
    let content = `/**
 * Tiling Data
 * Contains all the data structures for isohedral tiling types
 * This is extracted from the original monolithic tactile.js
 * 
 * Generated by extract-data.js on ${new Date().toISOString()}
 */

import { EdgeShape } from '../constants/EdgeShape.js';

// Edge shape definitions for each tiling type
`;

    // Add edge shapes
    Object.keys(data.edgeShapes).sort().forEach(name => {
        content += `const ${name} = [ ${data.edgeShapes[name]} ];\n`;
    });

    content += `\n// Edge shape indices for each tiling type\n`;
    
    // Add edge shape IDs
    Object.keys(data.edgeShapeIds).sort().forEach(name => {
        content += `const ${name} = [ ${data.edgeShapeIds[name]} ];\n`;
    });

    content += `\n// Edge orientations for each tiling type\n`;
    
    // Add edge orientations
    Object.keys(data.edgeOrientations).sort().forEach(name => {
        content += `const ${name} = [ ${data.edgeOrientations[name]} ];\n`;
    });

    content += `\n// Default parameters for each tiling type\n`;
    
    // Add default parameters
    Object.keys(data.defaultParams).sort().forEach(name => {
        content += `const ${name} = [ ${data.defaultParams[name]} ];\n`;
    });

    content += `\n// Vertex coefficients for each tiling type\n`;
    
    // Add vertex coefficients
    Object.keys(data.vertexCoeffs).sort().forEach(name => {
        content += `const ${name} = [\n    ${data.vertexCoeffs[name]}\n];\n`;
    });

    content += `\n// Translation coefficients for each tiling type\n`;
    
    // Add translation coefficients
    Object.keys(data.translationCoeffs).sort().forEach(name => {
        content += `const ${name} = [ ${data.translationCoeffs[name]} ];\n`;
    });

    content += `\n// Aspect coefficients for each tiling type\n`;
    
    // Add aspect coefficients
    Object.keys(data.aspectCoeffs).sort().forEach(name => {
        content += `const ${name} = [\n    ${data.aspectCoeffs[name]}\n];\n`;
    });

    content += `\n// Coloring data for each tiling type\n`;
    
    // Add coloring
    Object.keys(data.coloring).sort().forEach(name => {
        content += `const ${name} = [ ${data.coloring[name]} ];\n`;
    });

    content += `\n// Export all data structures\n`;
    content += `export {\n`;
    
    const allNames = [
        ...Object.keys(data.edgeShapes),
        ...Object.keys(data.edgeShapeIds),
        ...Object.keys(data.edgeOrientations),
        ...Object.keys(data.defaultParams),
        ...Object.keys(data.vertexCoeffs),
        ...Object.keys(data.translationCoeffs),
        ...Object.keys(data.aspectCoeffs),
        ...Object.keys(data.coloring)
    ].sort();

    allNames.forEach((name, index) => {
        content += `    ${name}${index < allNames.length - 1 ? ',' : ''}\n`;
    });

    content += `};\n`;

    return content;
}

// Verify data extraction
function verifyDataExtraction(data) {
    const verification = {
        success: true,
        errors: [],
        warnings: [],
        counts: {}
    };

    // Count each data type
    verification.counts.edgeShapes = Object.keys(data.edgeShapes).length;
    verification.counts.edgeShapeIds = Object.keys(data.edgeShapeIds).length;
    verification.counts.edgeOrientations = Object.keys(data.edgeOrientations).length;
    verification.counts.defaultParams = Object.keys(data.defaultParams).length;
    verification.counts.vertexCoeffs = Object.keys(data.vertexCoeffs).length;
    verification.counts.translationCoeffs = Object.keys(data.translationCoeffs).length;
    verification.counts.aspectCoeffs = Object.keys(data.aspectCoeffs).length;
    verification.counts.coloring = Object.keys(data.coloring).length;

    // Check for missing data types
    const expectedTypes = ['edgeShapes', 'edgeShapeIds', 'edgeOrientations', 'defaultParams', 'vertexCoeffs', 'translationCoeffs', 'aspectCoeffs', 'coloring'];
    expectedTypes.forEach(type => {
        if (verification.counts[type] === 0) {
            verification.errors.push(`No ${type} found in extraction`);
            verification.success = false;
        }
    });

    // Check for consistency in numbering
    const edgeShapeNumbers = Object.keys(data.edgeShapes).map(k => parseInt(k.match(/\d+/)[0])).sort();
    const edgeShapeIdNumbers = Object.keys(data.edgeShapeIds).map(k => parseInt(k.match(/\d+/)[0])).sort();
    
    if (edgeShapeNumbers.length !== edgeShapeIdNumbers.length) {
        verification.errors.push(`Mismatch in edge shape counts: ${edgeShapeNumbers.length} vs ${edgeShapeIdNumbers.length}`);
        verification.success = false;
    }

    // Check for gaps in numbering
    for (let i = 0; i < edgeShapeNumbers.length - 1; i++) {
        if (edgeShapeNumbers[i + 1] - edgeShapeNumbers[i] > 1) {
            verification.warnings.push(`Gap in edge shape numbering: ${edgeShapeNumbers[i]} to ${edgeShapeNumbers[i + 1]}`);
        }
    }

    return verification;
}

// Main execution
console.log('Extracting data from original tactile.js...');
const extractedData = extractDataStructures();

console.log('Verifying data extraction...');
const verification = verifyDataExtraction(extractedData);

console.log('Generating TilingData.js...');
const tilingDataContent = generateTilingDataFile(extractedData);

// Write the file
const outputFile = path.join(__dirname, 'lib', 'data', 'TilingData.js');
fs.writeFileSync(outputFile, tilingDataContent);

// Write verification report
const reportFile = path.join(__dirname, '..', '..', 'reports', 'data-extraction-report.json');
const report = {
    timestamp: new Date().toISOString(),
    verification,
    extractedData: {
        counts: verification.counts,
        sampleData: {
            edgeShapes: Object.keys(extractedData.edgeShapes).slice(0, 5),
            edgeShapeIds: Object.keys(extractedData.edgeShapeIds).slice(0, 5),
            edgeOrientations: Object.keys(extractedData.edgeOrientations).slice(0, 5),
            defaultParams: Object.keys(extractedData.defaultParams).slice(0, 5),
            vertexCoeffs: Object.keys(extractedData.vertexCoeffs).slice(0, 5),
            translationCoeffs: Object.keys(extractedData.translationCoeffs).slice(0, 5),
            aspectCoeffs: Object.keys(extractedData.aspectCoeffs).slice(0, 5),
            coloring: Object.keys(extractedData.coloring).slice(0, 5)
        }
    }
};

fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));

// Print results
console.log('\n=== Data Extraction Results ===');
console.log(`Success: ${verification.success}`);
console.log(`Output file: ${outputFile}`);
console.log(`Report file: ${reportFile}`);

console.log('\n=== Data Counts ===');
Object.entries(verification.counts).forEach(([type, count]) => {
    console.log(`${type}: ${count}`);
});

if (verification.errors.length > 0) {
    console.log('\n=== Errors ===');
    verification.errors.forEach(error => console.log(`❌ ${error}`));
}

if (verification.warnings.length > 0) {
    console.log('\n=== Warnings ===');
    verification.warnings.forEach(warning => console.log(`⚠️  ${warning}`));
}

console.log('\nData extraction complete!');
