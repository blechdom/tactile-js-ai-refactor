<!DOCTYPE html>
<html>
<head>
    <title>Data Structure Validation Tests</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        .results { background: #f5f5f5; padding: 10px; border-radius: 3px; max-height: 400px; overflow-y: auto; }
        .success { color: green; }
        .error { color: red; }
        .info { color: blue; }
        .warning { color: orange; }
        button { margin: 5px; padding: 8px 15px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }
        .test-section { margin: 15px 0; padding: 10px; border: 1px solid #ddd; border-radius: 5px; }
        .data-comparison { background: #fff; padding: 10px; margin: 10px 0; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>üß™ Data Structure Validation Tests</h1>
    
    <div class="test-section">
        <h3>üìã Test Suite for Data Structure Integrity</h3>
        <p>These tests ensure the data structure remains unchanged during refactoring.</p>
        
        <button onclick="runAllTests()">üöÄ Run All Data Structure Tests</button>
        <button onclick="testOriginalData()">üìä Test Original Data Structure</button>
        <button onclick="testDataConsistency()">üîÑ Test Data Consistency</button>
        <button onclick="testDataCompleteness()">‚úÖ Test Data Completeness</button>
        <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
    </div>
    
    <div id="results" class="results"></div>

    <script type="module">
        // Import the original library to test against
        import { IsohedralTiling, EdgeShape, numTypes, tilingTypes } from './lib/tactile.js';
        
        let testResults = {};
        let originalDataSnapshot = {};
        
        function log(message, type = 'info') {
            const resultsDiv = document.getElementById('results');
            const color = type === 'error' ? 'red' : type === 'success' ? 'green' : type === 'warning' ? 'orange' : 'blue';
            resultsDiv.innerHTML += `<div style="color: ${color}">${message}</div>`;
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }
        
        function clearResults() {
            document.getElementById('results').innerHTML = '';
            testResults = {};
        }
        
        // Test 1: Capture Original Data Structure
        function captureOriginalDataStructure() {
            log('üìä Capturing original data structure...', 'info');
            
            try {
                // Test a few tiling types to capture their structure
                const testTypes = [1, 2, 3, 4, 5];
                
                testTypes.forEach(typeId => {
                    try {
                        const tiling = new IsohedralTiling(typeId);
                        
                        originalDataSnapshot[typeId] = {
                            numParams: tiling.numParameters(),
                            numAspects: tiling.numAspects(),
                            numVertices: tiling.numVertices(),
                            numEdgeShapes: tiling.numEdgeShapes(),
                            parameters: tiling.getParameters(),
                            t1: tiling.getT1(),
                            t2: tiling.getT2(),
                            edgeShapes: [],
                            edgeShapeIds: [],
                            edgeOrientations: []
                        };
                        
                        // Capture edge information
                        for (let i = 0; i < tiling.numEdgeShapes(); i++) {
                            originalDataSnapshot[typeId].edgeShapes.push(tiling.getEdgeShape(i));
                        }
                        
                        // Capture edge shape IDs and orientations (if accessible)
                        // Note: These might be internal and not directly accessible
                        
                        log(`‚úÖ Captured data for type ${typeId}`, 'success');
                        
                    } catch (error) {
                        log(`‚ùå Failed to capture type ${typeId}: ${error.message}`, 'error');
                    }
                });
                
                log(`üìä Captured data for ${Object.keys(originalDataSnapshot).length} types`, 'success');
                
            } catch (error) {
                log(`‚ùå Data capture failed: ${error.message}`, 'error');
            }
        }
        
        // Test 2: Validate Data Structure Consistency
        function testDataConsistency() {
            log('üîÑ Testing data structure consistency...', 'info');
            
            if (Object.keys(originalDataSnapshot).length === 0) {
                log('‚ö†Ô∏è No original data captured. Run "Test Original Data Structure" first.', 'warning');
                return;
            }
            
            let consistencyIssues = 0;
            
            Object.entries(originalDataSnapshot).forEach(([typeId, originalData]) => {
                try {
                    const tiling = new IsohedralTiling(parseInt(typeId));
                    
                    // Check if properties match
                    if (tiling.numParameters() !== originalData.numParams) {
                        log(`‚ùå Type ${typeId}: Parameter count mismatch - Expected: ${originalData.numParams}, Got: ${tiling.numParameters()}`, 'error');
                        consistencyIssues++;
                    }
                    
                    if (tiling.numAspects() !== originalData.numAspects) {
                        log(`‚ùå Type ${typeId}: Aspect count mismatch - Expected: ${originalData.numAspects}, Got: ${tiling.numAspects()}`, 'error');
                        consistencyIssues++;
                    }
                    
                    if (tiling.numVertices() !== originalData.numVertices) {
                        log(`‚ùå Type ${typeId}: Vertex count mismatch - Expected: ${originalData.numVertices}, Got: ${tiling.numVertices()}`, 'error');
                        consistencyIssues++;
                    }
                    
                    if (tiling.numEdgeShapes() !== originalData.numEdgeShapes) {
                        log(`‚ùå Type ${typeId}: Edge shape count mismatch - Expected: ${originalData.numEdgeShapes}, Got: ${tiling.numEdgeShapes()}`, 'error');
                        consistencyIssues++;
                    }
                    
                    // Check parameter values
                    const currentParams = tiling.getParameters();
                    if (currentParams.length !== originalData.parameters.length) {
                        log(`‚ùå Type ${typeId}: Parameter array length mismatch`, 'error');
                        consistencyIssues++;
                    } else {
                        // Check if parameter values are the same (within tolerance)
                        for (let i = 0; i < currentParams.length; i++) {
                            if (Math.abs(currentParams[i] - originalData.parameters[i]) > 1e-10) {
                                log(`‚ùå Type ${typeId}: Parameter ${i} value changed - Expected: ${originalData.parameters[i]}, Got: ${currentParams[i]}`, 'error');
                                consistencyIssues++;
                            }
                        }
                    }
                    
                    // Check translation vectors
                    const currentT1 = tiling.getT1();
                    const currentT2 = tiling.getT2();
                    
                    if (Math.abs(currentT1.x - originalData.t1.x) > 1e-10 || Math.abs(currentT1.y - originalData.t1.y) > 1e-10) {
                        log(`‚ùå Type ${typeId}: T1 translation changed`, 'error');
                        consistencyIssues++;
                    }
                    
                    if (Math.abs(currentT2.x - originalData.t2.x) > 1e-10 || Math.abs(currentT2.y - originalData.t2.y) > 1e-10) {
                        log(`‚ùå Type ${typeId}: T2 translation changed`, 'error');
                        consistencyIssues++;
                    }
                    
                } catch (error) {
                    log(`‚ùå Type ${typeId}: Error during consistency check - ${error.message}`, 'error');
                    consistencyIssues++;
                }
            });
            
            if (consistencyIssues === 0) {
                log('‚úÖ All data structure consistency checks passed!', 'success');
            } else {
                log(`‚ö†Ô∏è Found ${consistencyIssues} consistency issues`, 'warning');
            }
        }
        
        // Test 3: Validate Data Completeness
        function testDataCompleteness() {
            log('‚úÖ Testing data completeness...', 'info');
            
            try {
                let totalTypes = 0;
                let validTypes = 0;
                let missingData = 0;
                
                // Test all valid tiling types
                for (let i = 0; i < tilingTypes.length; i++) {
                    const typeId = tilingTypes[i];
                    totalTypes++;
                    
                    try {
                        const tiling = new IsohedralTiling(typeId);
                        
                        // Check if all required data is present
                        if (tiling.numParameters() >= 0 && 
                            tiling.numAspects() > 0 && 
                            tiling.numVertices() > 0 && 
                            tiling.numEdgeShapes() > 0) {
                            validTypes++;
                        } else {
                            missingData++;
                            log(`‚ö†Ô∏è Type ${typeId}: Missing or invalid data`, 'warning');
                        }
                        
                    } catch (error) {
                        missingData++;
                        log(`‚ùå Type ${typeId}: Failed to create - ${error.message}`, 'error');
                    }
                }
                
                log(`üìä Data Completeness Summary:`, 'info');
                log(`   Total Types: ${totalTypes}`, 'info');
                log(`   Valid Types: ${validTypes}`, 'success');
                log(`   Missing Data: ${missingData}`, missingData > 0 ? 'warning' : 'success');
                log(`   Success Rate: ${((validTypes / totalTypes) * 100).toFixed(1)}%`, 'info');
                
                if (validTypes === totalTypes) {
                    log('üéâ All tiling types have complete data!', 'success');
                } else {
                    log('‚ö†Ô∏è Some tiling types are missing data', 'warning');
                }
                
            } catch (error) {
                log(`‚ùå Data completeness test failed: ${error.message}`, 'error');
            }
        }
        
        // Test 4: Run All Tests
        function runAllTests() {
            clearResults();
            log('üöÄ Running all data structure validation tests...', 'info');
            
            // Run tests in sequence
            setTimeout(() => {
                captureOriginalDataStructure();
                setTimeout(() => {
                    testDataConsistency();
                    setTimeout(() => {
                        testDataCompleteness();
                        log('üéØ All tests completed!', 'info');
                    }, 500);
                }, 500);
            }, 500);
        }
        
        // Test 5: Test Original Data Structure
        function testOriginalDataStructure() {
            clearResults();
            log('üìä Testing original data structure...', 'info');
            captureOriginalDataStructure();
        }
        
        // Make functions globally available
        window.runAllTests = runAllTests;
        window.testOriginalData = testOriginalDataStructure;
        window.testDataConsistency = testDataConsistency;
        window.testDataCompleteness = testDataCompleteness;
        window.clearResults = clearResults;
        
        // Auto-run basic test on page load
        window.onload = function() {
            log('üß™ Data structure validation test environment loaded!', 'info');
            log('üìä This will ensure data integrity during refactoring.', 'info');
            log('üöÄ Click "Run All Data Structure Tests" to begin validation.', 'info');
        };
    </script>
</body>
</html>
