#!/usr/bin/env node

/**
 * Final Data Extraction Script for Tactile-JS
 * 
 * This script extracts all data structures from the original tactile.js file
 * and generates a complete TilingData.js file with proper verification.
 * 
 * Correctly handles the mapping between data arrays and tiling types.
 */

const fs = require('fs');
const path = require('path');

// Read the original tactile.js file
const originalFile = path.join(__dirname, '..', '..', 'lib', 'tactile.js');
const originalContent = fs.readFileSync(originalFile, 'utf8');

// Extract all data structures
function extractDataStructures() {
    const data = {
        edgeShapes: {},
        edgeShapeIds: {},
        edgeOrientations: {},
        defaultParams: {},
        vertexCoeffs: {},
        translationCoeffs: {},
        aspectCoeffs: {},
        coloring: {},
        tilingTypeDefinitions: {},
        validTilingTypes: []
    };

    // Extract edge shapes (es_XX)
    const esMatches = originalContent.match(/const es_\d+ = \[[^\]]+\]/g);
    esMatches.forEach(match => {
        const name = match.match(/es_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.edgeShapes[name] = values;
    });

    // Extract edge shape IDs (esi_XX)
    const esiMatches = originalContent.match(/const esi_\d+ = \[[^\]]+\]/g);
    esiMatches.forEach(match => {
        const name = match.match(/esi_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.edgeShapeIds[name] = values;
    });

    // Extract edge orientations (eo_XX)
    const eoMatches = originalContent.match(/const eo_\d+ = \[[^\]]+\]/g);
    eoMatches.forEach(match => {
        const name = match.match(/eo_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.edgeOrientations[name] = values;
    });

    // Extract default parameters (dp_XX)
    const dpMatches = originalContent.match(/const dp_\d+ = \[[^\]]+\]/g);
    dpMatches.forEach(match => {
        const name = match.match(/dp_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.defaultParams[name] = values;
    });

    // Extract vertex coefficients (tvc_XX)
    const tvcMatches = originalContent.match(/const tvc_\d+ = \[[\s\S]*?\];/g);
    tvcMatches.forEach(match => {
        const name = match.match(/tvc_\d+/)[0];
        const values = match.match(/\[([\s\S]*?)\];/)[1];
        data.vertexCoeffs[name] = values;
    });

    // Extract translation coefficients (tc_XX)
    const tcMatches = originalContent.match(/const tc_\d+ = \[[^\]]+\]/g);
    tcMatches.forEach(match => {
        const name = match.match(/tc_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.translationCoeffs[name] = values;
    });

    // Extract aspect coefficients (ac_XX)
    const acMatches = originalContent.match(/const ac_\d+ = \[[\s\S]*?\];/g);
    acMatches.forEach(match => {
        const name = match.match(/ac_\d+/)[0];
        const values = match.match(/\[([\s\S]*?)\];/)[1];
        data.aspectCoeffs[name] = values;
    });

    // Extract coloring (c_XX)
    const cMatches = originalContent.match(/const c_\d+ = \[[^\]]+\]/g);
    cMatches.forEach(match => {
        const name = match.match(/c_\d+/)[0];
        const values = match.match(/\[([^\]]+)\]/)[1];
        data.coloring[name] = values;
    });

    // Extract valid tiling types from the array
    const tilingTypesMatch = originalContent.match(/const tilingTypes = \[([^\]]+)\]/);
    if (tilingTypesMatch) {
        const tilingTypesStr = tilingTypesMatch[1];
        data.validTilingTypes = tilingTypesStr.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
    }

    // Extract tiling type definitions
    const tilingDefMatches = originalContent.match(/\/\/ IH\d+\s*\n\s*\{\s*\n([\s\S]*?)\s*\n\s*\}/g);
    tilingDefMatches.forEach((match, index) => {
        const tilingTypeNum = index + 1; // IH01 is at index 1
        if (data.validTilingTypes.includes(tilingTypeNum)) {
            const definition = extractTilingDefinition(match);
            data.tilingTypeDefinitions[tilingTypeNum] = definition;
        }
    });

    return data;
}

function extractTilingDefinition(match) {
    const lines = match.split('\n');
    const definition = {};
    
    lines.forEach(line => {
        const trimmed = line.trim();
        if (trimmed.includes(':')) {
            const [key, value] = trimmed.split(':').map(s => s.trim());
            if (key && value) {
                // Remove trailing comma if present
                const cleanValue = value.replace(/,$/, '');
                definition[key] = cleanValue;
            }
        }
    });
    
    return definition;
}

// Generate the complete TilingData.js file
function generateTilingDataFile(data) {
    let content = `/**
 * Tiling Data
 * Contains all the data structures for isohedral tiling types
 * This is extracted from the original monolithic tactile.js
 * 
 * Generated by extract-data-final.js on ${new Date().toISOString()}
 * 
 * Valid tiling types: ${data.validTilingTypes.join(', ')}
 */

import { EdgeShape } from '../constants/EdgeShape.js';

// Edge shape definitions for each tiling type
`;

    // Add edge shapes
    Object.keys(data.edgeShapes).sort().forEach(name => {
        content += `const ${name} = [ ${data.edgeShapes[name]} ];\n`;
    });

    content += `\n// Edge shape indices for each tiling type\n`;
    
    // Add edge shape IDs
    Object.keys(data.edgeShapeIds).sort().forEach(name => {
        content += `const ${name} = [ ${data.edgeShapeIds[name]} ];\n`;
    });

    content += `\n// Edge orientations for each tiling type\n`;
    
    // Add edge orientations
    Object.keys(data.edgeOrientations).sort().forEach(name => {
        content += `const ${name} = [ ${data.edgeOrientations[name]} ];\n`;
    });

    content += `\n// Default parameters for each tiling type\n`;
    
    // Add default parameters
    Object.keys(data.defaultParams).sort().forEach(name => {
        content += `const ${name} = [ ${data.defaultParams[name]} ];\n`;
    });

    content += `\n// Vertex coefficients for each tiling type\n`;
    
    // Add vertex coefficients
    Object.keys(data.vertexCoeffs).sort().forEach(name => {
        content += `const ${name} = [\n    ${data.vertexCoeffs[name]}\n];\n`;
    });

    content += `\n// Translation coefficients for each tiling type\n`;
    
    // Add translation coefficients
    Object.keys(data.translationCoeffs).sort().forEach(name => {
        content += `const ${name} = [ ${data.translationCoeffs[name]} ];\n`;
    });

    content += `\n// Aspect coefficients for each tiling type\n`;
    
    // Add aspect coefficients
    Object.keys(data.aspectCoeffs).sort().forEach(name => {
        content += `const ${name} = [\n    ${data.aspectCoeffs[name]}\n];\n`;
    });

    content += `\n// Coloring data for each tiling type\n`;
    
    // Add coloring
    Object.keys(data.coloring).sort().forEach(name => {
        content += `const ${name} = [ ${data.coloring[name]} ];\n`;
    });

    content += `\n// Valid tiling type numbers\n`;
    content += `export const VALID_TILING_TYPES = [${data.validTilingTypes.join(', ')}];\n`;
    content += `export const NUM_TILING_TYPES = ${data.validTilingTypes.length};\n`;

    content += `\n// Tiling type definitions mapping\n`;
    content += `export const TILING_TYPE_DEFINITIONS = {\n`;
    Object.entries(data.tilingTypeDefinitions).forEach(([typeNum, definition]) => {
        content += `    ${typeNum}: {\n`;
        Object.entries(definition).forEach(([key, value]) => {
            content += `        ${key}: ${value},\n`;
        });
        content += `    },\n`;
    });
    content += `};\n`;

    content += `\n// Export all data structures\n`;
    content += `export {\n`;
    
    const allNames = [
        ...Object.keys(data.edgeShapes),
        ...Object.keys(data.edgeShapeIds),
        ...Object.keys(data.edgeOrientations),
        ...Object.keys(data.defaultParams),
        ...Object.keys(data.vertexCoeffs),
        ...Object.keys(data.translationCoeffs),
        ...Object.keys(data.aspectCoeffs),
        ...Object.keys(data.coloring)
    ].sort();

    allNames.forEach((name, index) => {
        content += `    ${name}${index < allNames.length - 1 ? ',' : ''}\n`;
    });

    content += `};\n`;

    return content;
}

// Verify data extraction
function verifyDataExtraction(data) {
    const verification = {
        success: true,
        errors: [],
        warnings: [],
        counts: {},
        validTilingTypes: data.validTilingTypes,
        tilingTypeDefinitions: Object.keys(data.tilingTypeDefinitions).length
    };

    // Count each data type
    verification.counts.edgeShapes = Object.keys(data.edgeShapes).length;
    verification.counts.edgeShapeIds = Object.keys(data.edgeShapeIds).length;
    verification.counts.edgeOrientations = Object.keys(data.edgeOrientations).length;
    verification.counts.defaultParams = Object.keys(data.defaultParams).length;
    verification.counts.vertexCoeffs = Object.keys(data.vertexCoeffs).length;
    verification.counts.translationCoeffs = Object.keys(data.translationCoeffs).length;
    verification.counts.aspectCoeffs = Object.keys(data.aspectCoeffs).length;
    verification.counts.coloring = Object.keys(data.coloring).length;

    // Check for missing data types
    const expectedTypes = ['edgeShapes', 'edgeShapeIds', 'edgeOrientations', 'defaultParams', 'vertexCoeffs', 'translationCoeffs', 'aspectCoeffs', 'coloring'];
    expectedTypes.forEach(type => {
        if (verification.counts[type] === 0) {
            verification.errors.push(`No ${type} found in extraction`);
            verification.success = false;
        }
    });

    // Check that we have definitions for all valid tiling types
    data.validTilingTypes.forEach(typeNum => {
        if (!data.tilingTypeDefinitions[typeNum]) {
            verification.errors.push(`Missing definition for tiling type ${typeNum}`);
            verification.success = false;
        }
    });

    // Check that all referenced data arrays exist
    Object.entries(data.tilingTypeDefinitions).forEach(([typeNum, definition]) => {
        const requiredFields = ['edge_shapes', 'edge_shape_ids', 'edge_orientations', 'default_params', 'vertex_coeffs', 'translation_coeffs', 'aspect_coeffs', 'colouring'];
        
        requiredFields.forEach(field => {
            if (definition[field]) {
                const arrayName = definition[field];
                const dataType = getDataTypeFromName(arrayName);
                if (dataType && !data[dataType][arrayName]) {
                    verification.errors.push(`Missing ${arrayName} referenced by tiling type ${typeNum}`);
                    verification.success = false;
                }
            }
        });
    });

    return verification;
}

function getDataTypeFromName(arrayName) {
    if (arrayName.startsWith('es_')) return 'edgeShapes';
    if (arrayName.startsWith('esi_')) return 'edgeShapeIds';
    if (arrayName.startsWith('eo_')) return 'edgeOrientations';
    if (arrayName.startsWith('dp_')) return 'defaultParams';
    if (arrayName.startsWith('tvc_')) return 'vertexCoeffs';
    if (arrayName.startsWith('tc_')) return 'translationCoeffs';
    if (arrayName.startsWith('ac_')) return 'aspectCoeffs';
    if (arrayName.startsWith('c_')) return 'coloring';
    return null;
}

// Main execution
console.log('Extracting data from original tactile.js...');
const extractedData = extractDataStructures();

console.log('Verifying data extraction...');
const verification = verifyDataExtraction(extractedData);

console.log('Generating TilingData.js...');
const tilingDataContent = generateTilingDataFile(extractedData);

// Write the file
const outputFile = path.join(__dirname, '..', '..', 'lib', 'data', 'TilingData.js');
fs.writeFileSync(outputFile, tilingDataContent);

// Write verification report
const reportFile = path.join(__dirname, '..', '..', 'reports', 'data-extraction-report-final.json');
const report = {
    timestamp: new Date().toISOString(),
    verification,
    extractedData: {
        counts: verification.counts,
        validTilingTypes: extractedData.validTilingTypes,
        tilingTypeDefinitions: Object.keys(extractedData.tilingTypeDefinitions).length,
        sampleData: {
            edgeShapes: Object.keys(extractedData.edgeShapes).slice(0, 5),
            edgeShapeIds: Object.keys(extractedData.edgeShapeIds).slice(0, 5),
            edgeOrientations: Object.keys(extractedData.edgeOrientations).slice(0, 5),
            defaultParams: Object.keys(extractedData.defaultParams).slice(0, 5),
            vertexCoeffs: Object.keys(extractedData.vertexCoeffs).slice(0, 5),
            translationCoeffs: Object.keys(extractedData.translationCoeffs).slice(0, 5),
            aspectCoeffs: Object.keys(extractedData.aspectCoeffs).slice(0, 5),
            coloring: Object.keys(extractedData.coloring).slice(0, 5)
        }
    }
};

fs.writeFileSync(reportFile, JSON.stringify(report, null, 2));

// Print results
console.log('\n=== Data Extraction Results ===');
console.log(`Success: ${verification.success}`);
console.log(`Output file: ${outputFile}`);
console.log(`Report file: ${reportFile}`);

console.log('\n=== Valid Tiling Types ===');
console.log(`Count: ${extractedData.validTilingTypes.length}`);
console.log(`Types: ${extractedData.validTilingTypes.join(', ')}`);

console.log('\n=== Tiling Type Definitions ===');
console.log(`Extracted: ${Object.keys(extractedData.tilingTypeDefinitions).length}`);

console.log('\n=== Data Counts ===');
Object.entries(verification.counts).forEach(([type, count]) => {
    console.log(`${type}: ${count}`);
});

if (verification.errors.length > 0) {
    console.log('\n=== Errors ===');
    verification.errors.forEach(error => console.log(`❌ ${error}`));
}

if (verification.warnings.length > 0) {
    console.log('\n=== Warnings ===');
    verification.warnings.forEach(warning => console.log(`⚠️  ${warning}`));
}

console.log('\nData extraction complete!');

